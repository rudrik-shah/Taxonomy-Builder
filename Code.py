# -*- coding: utf-8 -*-
"""Krr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bz2Kq6NwftJ9l_v_E6762rEFz6vLzEJY
"""

import xml.etree.ElementTree as ET

# Main function
if __name__ == "__main__":
  
    dictionary = {}
    tree = ET.parse("input/input.xml")
    root = tree.getroot()  

    for child in root.findall("Class"):
        
        # Get class name as key
        key = child.find('CONCEPT').text  
        
        # Get subclasses in a set
        setData = set()                  

        # Handle "SubClassOf" part
        for newChild in child.findall('SubClassOf'):

            #handle the EXISTS case
            if(newChild.find('EXISTS') != None):
                setData.add(newChild.find('ROLE').text +
                            " some " + newChild.find('CONCEPT').text)
                
            # Handle the Not subclass case
            if(newChild.find('NOT') != None):
                for notChild in newChild.findall('NOT'):
                    setData.add("not "+notChild.find('CONCEPT').text)

            # Get all sub class values
            if(newChild.find('CONCEPT') != None):
                setData.add(newChild.find('CONCEPT').text)

            # Handle the AND subclass case
            if(newChild.find('AND') != None):

                for newChild in child.findall('EquivalentTo'):

                    if(newChild.find('NOT') != None):
                        for notChild in newChild.findall('NOT'):
                            setData.add("not "+notChild.find('CONCEPT').text) 
                    
                    if(newChild.find('EXISTS') != None):
                        setData.add(newChild.find('ROLE').text +
                                    " some " + newChild.find('CONCEPT').text)

                    if(newChild.find('CONCEPT') != None):
                        setData.add(newChild.find('CONCEPT').text)

        # Handle "Equivalent to" part
        for newChild in child.findall('EquivalentTo'):

            if(newChild.find('NOT') != None):
                for notChild in newChild.findall('NOT'):
                    setData.add("not "+notChild.find('CONCEPT').text)

            if(newChild.find('EXISTS') != None):
                setData.add(newChild.find('ROLE').text +
                            " some " + newChild.find('CONCEPT').text)
                
            if(newChild.find('CONCEPT') != None):
              setData.add(newChild.find('CONCEPT').text)

            if(newChild.find('AND') != None):
                for newnewChild in newChild.findall('AND'):

                    if(newnewChild.find('NOT') != None):
                        for notChild in newnewChild.findall('NOT'):
                            setData.add("not "+notChild.find('CONCEPT').text)

                    if(newnewChild.find('EXISTS') != None):
                        setData.add(newnewChild.find('EXISTS').find(
                            'ROLE').text+" some " + newnewChild.find('EXISTS').find('CONCEPT').text)
                        
                    if(newnewChild.find('CONCEPT') != None):
                        setData.add(newnewChild.find('CONCEPT').text)

        dictionary[key] = setData


    # Handle the transitivity
    dic = {}
    while(dic != dictionary):
        dic = dictionary.copy()
        for key in dictionary:
            news = dictionary[key]
            for item in dictionary[key]:
                if item in dictionary:
                    for i in dictionary[item]:
                        if i in dictionary:
                            news = news.union({i})

            dictionary[key] = news

# write the data to the ouput file
file = open("output/output.txt", 'w')

for data in dictionary:
    file.write('Class: ' + data + '\n')
    listData = list(dictionary[data])

    if bool(dictionary[data]):
        file.write("\tSubClassOf: ")
        for item in listData[:-1]:
            file.write(item+', ')

        file.write(listData[-1])
        file.write("\n")